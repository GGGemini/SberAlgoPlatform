using System.Collections.Immutable;

namespace Test3
{
    internal class Program
    {
        static void Main(string[] args)
        {
            /*
             * Есть метод, выполняющий асинхронные задачи с некоторым модификатором конкурентности (concurrency).  Как мы будем подбирать этот параметр. Интересуют рассуждения о причинах выбора того или иного значения в разных ситуациях, когда внутри workload:
             * 1. запросы к REST API другой команды.
             * 2. публикации в message bus.
             * 3. запись на диск.
             * 4. вставка в БД.
             * 5. рендеринг pdf страниц на основании готовых датасетов в памяти.
             */

            /*
             * 1. Запросы к другому API обычно ограничены для того, чтобы не перегрузить сервер партнёра.
             * Поэтому, если есть возможность контактировать с коллегами компании, к которой мы делаем запрос,
             * то лучшим решением будет спросить у них напрямую, какое ограничение нам поставить лучше всего,
             * чтобы их сервер чувствовал себя комфортно, ведь у них есть картина, сколько у них таких клиентов, как мы,
             * и они смогут трезво оценить ресурсы своих серверов, чтобы понять, сколько они могут "выделить" нам.
             * 
             * Другой случай, когда связи с партнёрами нет и связаться мы с ними не можем, то на помощь нам придёт
             * документация, в которой, возможно, будет указано, какое количество запросов мы можем делать
             * (в секунду/в минуту/в час/в день).
             * 
             * Ну и самый худший случай (для нас), когда мы пытаемся не совсем честно автоматизировать запрос
             * к какому-либо API без документации. В таком случае нам придётся методом тыка подбирать
             * оптимальную частоту выполнения запросов и проверять возможность выполнения одновременных запросов.
             * Есть шанс нарваться на блокировку по ip-адресу - на какое-то время или перманентно, поэтому в таком случае
             * лучше делать запросы последовательно, создавая какую-нибудь искусственную задержку "await Task.Delay(1000)".
             * 
             * Также количество запросов может быть ограничено скоростью нашего интернет-соединения.
             */

            /*
             * 2. Для подбора concurrency важно учитывать пропускную способность нашей системы сообщений,
             * а также учитывать места, где отправка сообщений в message bus уже используется, чтобы не перегрузить
             * сервер сообщений, что может привести к задержкам или потерям некоторых сообщений, которые могут оказаться важны.
             * Думаю, что всё зависит от возможностей брокера сообщений, который мы используем, и от мощности сервера сообщений.
             */

            /*
             * 3. При записи данных на диск стоит учитывать его характеристики (скорость записи).
             * К примеру, если мы имеем дело с каким-то общим диском HDD, который является общедоступным,
             * то стоит выбрать маленькую скорость записи, чтобы не ограничивать своих коллег, которым он тоже может понадобиться.
             * А если же речь идёт о мощном SSD, который обладает высокой скоростью записи данных,
             * то можно выбрать большой concurrency.
             */

            /*
             * 4. Вставка записей в базу данных записит от используемой нами СУБД и мощности сервера, на котором она находится.
             * 
             * MS SQL.
             * Хорошо подходит для обработки высоких уровней параллелизма.
             * Также для оптимизации вставки можно добавить:
             * - транзакции, чтобы сгруппировать несколько операций вставки в один "коммит", что снизит накладные расходы
             *   на операции записи.
             * - пул подключений, чтобы уменьшить время и ресурсы, необходимые для открытия и закрытия подключений.
             * - горизонтальное и вертикальное масштабирование, чтобы увеличить производительность за счёт добавления
             *   ресурсов и узлов.
             *   
             * PostgreSQL.
             * PostgreSQL известен своей мощной поддержкой параллелизма и может хорошо масштабироваться для обработки
             * больших объемов транзакций.
             * У PostgreSQL есть несколько инструментов для оптимизации параллельных запросов:
             * - MVCC (Multiversion Concurrency Control): PostgreSQL использует MVCC для управления параллелизмом,
             *   что позволяет нескольким процессам безопасно читать и писать в базу данных одновременно.
             * - Тюнинг: Настройка параметров, таких как "max_connections", "shared_buffers", "work_mem" и других,
             *   может значительно повлиять на производительность параллельных вставок.
             * - Write-Ahead Logging (WAL): PostgreSQL использует WAL для улучшения надежности,
             *   но его настройка также может повлиять на скорость записи.
             *   
             * SQLite.
             * SQLite — это легковесная встраиваемая СУБД, которая не предназначена для высокой параллелизации и
             * может оказаться бутылочным горлышком при множественных одновременных записях.             * 
             * У SQLite есть следующие особенности, которые можно выделить:
             * - Файловая блокировка: SQLite блокирует всю базу данных при записи,
             *   что может стать проблемой при высокой параллелизации.
             * - Однопоточность: SQLite лучше всего работает в приложениях с однопоточным доступом или ограниченным параллелизмом.
             * 
             * Таким образом, выбор concurrency для записи в БД зависит от:
             * - мощности сервера, на котором у нас находится БД;
             * - СУБД, которую мы используем, и от её настроек.
             */

            /*
             * 5. Генерация PDF зависит от мощности CPU, поэтому распараллеливание этих задач зависит от количества
             * ядер и потоков процессора и от его нагруженности.
             * 
             * Наиболее оптимальное значение concurrency в данном случае находится эмпирическим методом, путём подбора
             * оптимального числа, замеров времени выполнения программы,
             * чтобы соблюсти баланс между использованием ресурсов компьютера и производительностью.
             */
        }

        async Task<ImmutableArray<uint>> Process(Func<Task<uint>>[] workload, int concurrency)
        {
            var aggregateRes = new List<uint>(workload.Length);

            // разбиваем на равные кусочки для ограничения числа одновременно выполняемых операций
            foreach (var chunk in workload.Chunk(concurrency))
            {
                var res = await Task.WhenAll(chunk.Select(x => x()));

                aggregateRes.AddRange(res);
            }

            return aggregateRes.ToImmutableArray();
        }

    }
}
